# Goald: Return False if any row, column, or 3x3 subgrid contains duplicate numbers (excluding 0).
# Helper function to check duplicates: Checks a list, compare its length to the length of its set. Returns True if no duplicates, False otherwise.
# Rows: Check each row list directly using the helper.
# Columns: Use zip(*board) to iterate over columns as lists with the helper.
# Subgrids:
    # Each subgrid is 3x3.
    # Starting points for subgrids are generated by nested loops: for row in range(0, 9, 3) and for col in range(0, 9, 3).
    # For each starting point, collect all cells within the 3x3 block and check for duplicates using the helper.
# T: O(1) - constant 9*9*3 checks 
# O: O(1) - subgrid size is always 9

def valid_sudoku(grid):
    def has_duplicates(list):
        list = [ele for ele in list if ele!= 0]
        return len(list) != len(set(list))
    
    for row in grid:
        if has_duplicates(row):
            return False
    for col in zip(*grid):
        if has_duplicates(col):
            return False
    for subgrid_r in range(0, 9, 3):
        for subgrid_c in range(0, 9, 3):
            cells = []
            for row in range(3):
                for col in range(3):
                    cells.append(grid[subgrid_r + row][subgrid_c + col])
            if has_duplicates(cells):
                return False
    return True                                                 



# # Valid Sudoku

# Given a 9x9 grid `board` representing a Sudoku, return `true` if the board does not have any conflicts and `false` otherwise. The board contains only numbers between 0 and 9 in each cell, with 0's denoting empty cells.

# A conflict is a duplicate number (other than 0) along a row, a column, or a 3x3 subgrid (shown with the thicker outline). For the purposes of this problem, it doesn't matter if the Sudoku has a valid solution or not -- only whether it has a conflict in the already-filled cells.

# For those who don't know the rules of Sudoku: the grid starts off with some cells pre-filled with numbers. The player is asked to fill in the empty cells with the numbers 1 through 9, such that there are no duplicates in the same row, column, or subgrid (the 3x3 sections shown with the thicker outline).

# Example 1:
# board = +-------+-------+-------+
#         | 5 . . | . . . | . . 6 |
#         | . . 9 | . 5 . | 3 . . |
#         | . 3 . | . . 2 | . . . |
#         +-------+-------+-------+
#         | 8 . . | 7 . . | . . 9 |
#         | . . 2 | . . . | 8 . . |
#         | 4 . . | . . 6 | . . 3 |
#         +-------+-------+-------+
#         | . . . | 3 . . | . 4 . |
#         | . . 3 | . 8 . | 2 . . |
#         | 9 . . | . . . | . . 7 |
#         +-------+-------+-------+
# Output: true

# Example 2:
# board = +-------+-------+-------+
#         | 5 . . | . . . | . . 6 |
#         | . . 9 | . 5 . | 3 . . |
#         | . 3 . | . . 2 | . . . |
#         +-------+-------+-------+
#         | 8 . . | 7 . . | . . 9 |
#         | . . 2 | . . . | 8 . . |
#         | 4 . . | . . 6 | . . 3 |
#         +-------+-------+-------+
#         | . . . | 3 . . | . 4 . |
#         | . . 3 | . 8 . | 7 . . |
#         | 9 . . | . . . | . . 7 |
#         +-------+-------+-------+
# Output: false
# Explanation: The bottom-right 3x3 subgrid has a duplicate, 7.

# Example 3:
# board = +-------+-------+-------+
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         +-------+-------+-------+
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         +-------+-------+-------+
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         | . . . | . . . | . . . |
#         +-------+-------+-------+
# Output: true
# Explanation: An empty board has no conflicts.

# https://iio-beyond-ctci-images.s3.us-east-1.amazonaws.com/valid-sudoku-1.png

# Constraints:

# - board.length == 9
# - board[i].length == 9
# - board[i][j] is a digit between 0 and 9.